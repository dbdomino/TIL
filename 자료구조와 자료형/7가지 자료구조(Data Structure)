1. 배열
2. 연속 리스트
3. 연결 리스트
4. 스택 (중요)
5. 큐   (중요)
6. 그래프 (중요)
7. 트리   (중요)

첫째로, 배열(Array)은 가장 기본적인 데이터 구조이다. 배열은 생성되는 순간 설정되는 셀에 인덱스가 부여되고 해당 셀의 개수는 고정된다. 이때 부여된 인덱스를 통해 원하는 데이터에 접근할 수 있다. 배열은 바로 만들어서 활용하기가 쉽고 원하는 데이터를 효율적으로 검색하여 가져오는 게 가능하다. 배열을 기반으로 하여 더 복잡한 자료 구조를 만들 수 있으며 정렬이 용이하다는 장점이 있다. 그러나 생성될 때 셀의 개수가 고정되므로 데이터를 저장할 수 있는 메모리의 크기가 고정되어 있고 데이터를 추가, 삭제하는 과정이 비효율적이다. 데이터가 삭제되고 나면 남는 셀은 빈 공간이 되므로 메모리의 낭비가 심하다.

두 번째로 연속 리스트(Contiguous List)는 배열처럼 연속적인 기억 장소에 데이터가 저장되는 자료구조이다. 연속적으로 데이터가 저장되어 있어 검색에는 용이하지만, 데이터의 삽입이나 삭제는 용이하지 않다. 삽입과 삭제가 일어나는 경우 자료의 이동이 필요하다는 번거로움이 있기 때문이다.

세 번째로 연결 리스트(Linked List)는 데이터를 임의의 기억공간에 기억시키되, 데이터 항목의 순서에 따라 노드의 포인터를 이요하여 서로 연결시킨 자료구조이다. 새로운 데이터를 추가하고 삭제하는 것이 용이하고 효율적이다. 배열처럼 메모리에 연속적으로 위치하지 않고 구조의 재구성이 필요 없다. 메모리를 더 효율적으로 사용할 수 있기 때문에 대용량의 데이터의 처리에 적합하다. 하지만 연결이 끊어지면 다음 노드를 찾기가 어렵고 속도가 느리다는 단점이 있다.

네 번째로 스택(Stack)은 순서가 유지되는 선형 데이터 구조이다. 리스트의 한쪽에서만 데이터의 삽입과 삭제가 일어나므로, 가장 마지막 요소부터 가장 처음 요소를 처리하는 LIFO(Last In First Out) 메커니즘을 갖고 있다. 기억공간이 부족한 경우 데이터를 삽입하는 경우 오버플로(Overflow)가 발생하고 삭제할 데이터가 없을 때 데이터를 삭제하고자 하면 언더 플로(Underflow)가 발생한다. 데이터를 받는 순서대로 정렬되고 메모리의 크기가 동적이지만 한 번에 하나의 데이터만 처리할 수 있는 불편함이 있다.

다섯 번째로 큐(Queue)는 스택과 비슷하지만 먼저 입력된 요소를 먼저 처리하는 FIFO(First In First Out) 메커니즘을 가진다. 리스트의 한쪽에서는 삽입이 일어나고 다른 쪽에서는 삭제가 일어난다. 데이터의 시작 부분을 프런트(Front)라 하고 끝 부분은 리어(Rear)라고 한다. 동적인 메모리 크기와 빠른 런타임을 자랑하지만 가장 오래된 요소만을 가져오고 한 번에 하나의 데이터만 처리하는 단점이 있다.

여섯 번째로 그래프(Graph)는 정점(Vertex)과 간선(Edge)으로 이루어진 데이터 구조이며 사이클이 없는 그래프를 특별히 트리라고 한다. 방향 그래프와 무방향 그래프가 있다. 새로운 요소들의 추가나 삭제가 용이하고 구조를 응용하기에 적합하다. 하지만 데이터 간에 충돌이 일어날 수 있다는 단점도 있다.

마지막으로 트리(Tree)는 노드(Node)로 구성된 계층적인 자료구조이다. 최상위 노드(루트, Root)를 만들고 그 아래에 자식을 추가하는 방식으로 트리구조는 다양하게 구현할 수 있다. 노드와 노드를 잇는 선을 간선(Edge)이라 한다. 같은 부모(Parent) 노드를 가지며 같은 레벨에 있는 노드를 형제(Siblings) 노드라 하고 자식이 없는 노드를 단말(Terminal) 노드라고 한다.
