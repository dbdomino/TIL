 Iterator를 통한 순회는 반복문을 통한 순회와는 메모리적으로 중요한 차이가 있다.

LinkedList를 통해 예를 들어보겠다.

 public void linkedListTest() {
        LinkedList<Integer> list = new LinkedList<Integer>();
        
        for(int i = 0;i <= 100; i++) {
            list.add(i);
        }
        
        for(int i = 0; i<= 100; i++) {
            list.get(i);
        }
    }
    
add 메서드를 이용해 데이터 입력이 다 끝나면 위 그림과 같은 구조가 된다.

그리고 get(0)부터 get(100)까지를 수행하게 되는데 이는 0부터 100까지 총 101번의 요소를 조회하는게 아니다.

get(int index) 메서드는 시작 주소부터 index 만큼 요소들을 밟아가며 조회하는 메서드이기 때문이다.

만약 5번째 값을 조회한다면 처음 시작주소부터 시작하여 다음주소를 타고... 타고.. 를 총 5번 반복해야한다.

get 메서드가 실행되며 i 값이 증가할 때마다 메모리적으로 조회해야 하는 요소는 1번, 2번, 3번, 4번... 101번까지 증가하는 것이다. 총 5151번을 조회해야 한다.

 

이에반해 Iterator는 1부터 101번째까지의 요소에 대해 내부적으로 객체로 생성한 후 순차적으로 조회한다.

처음 주소로 돌아갈 필요가 없기때문에 next 메서드를 통해 조회 시 요소의 개수인 101번만 조회를 하게된다.

 

그렇다면 드는 생각. 속도면에서 훨씬 빠르지않을까?

 

훨씬 빠를것이라고 생각했으나... Iterator를 구현하기 위해 객체를 생성하는 부분에서 시간이 더 걸린다고 한다.

물론 그 차이는 크지 않지만...

 

결론.

 Iterator는 컬렉션 프레임워크에 대한 인터페이스이고, 사용법이 쉽다.

 하지만 반복문보다 속도면에서 조금 느리다는 평이 있다.
