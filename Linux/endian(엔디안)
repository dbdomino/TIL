엔디언(Endianness)은 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법을 특히 바이트 순서(Byte order)라 한다.

바이트 저장 순서
컴퓨터는 데이터를 메모리에 저장할 때 Byte 단위로 나눠서 저장한다. 따라서 연속되는 바이트를 순서대로 저장해야 하는데, 이것을 바이트 저장 순서(Byte Order)라고 한다. 
이때 바이트가 저장된 순서에 따라 빅 엔디안, 리틀 엔디안 두 가지 방식으로 나눌 수 있다.
 

빅 엔디안(Big-endian)
빅 엔디안 방식은 낮은 주소에 데이터의 높은 바이트(MSB : Most Significant Byte)부터 저장하는 방식이다.
이 방식은 평소 사람이 사용하는 선형 방식과 같아 메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기 쉽다.
 
예를 들어, 아래와 같이 저장할 32bit 크기의 정수가 있다고 가정하자.

0x12345678
그럼 이 정수는 아래와 같이 4개의 byte (4byte == 32bit)로 나뉜다.
0x12, 0x34, 0x56, 0x78 
이 4개의 바이트 값을 빅 엔디안은 다음과 같이 저장한다.
  

리틀 엔디안(Little-endian)
리틀 엔디안 방식은 낮은 주소에 데이터의 낮은 바이트(LSB : Least Significant Byte)를 저장하는 방식이다.
이 방식은 평소 사람이 숫자를 사용하는 선형 방식과 반대로 거꾸로 읽어야 한다. 
 
앞서 예시를 든 "0x12345678"를 리틀 엔디안 방식으로 저장하면 다음과 같다.

 


빅 엔디안 vs 리틀 엔디안
빅 엔디안과 리틀 엔디안 중 어느 한쪽이 다른 쪽과 비교해 압도적으로 좋거나 나쁘지는 않다고 알려져 있다. 두 방법은 서로 다른 아키텍처에서 공존하고 있다. 그러나 x86 아키텍처가 리틀 엔디안을 쓰기 때문에 오늘날 x86 아키텍처를 사용하는 대부분의 데스크톱 컴퓨터는 리틀 엔디언 방식을 사용한다. 반면, 네트워크에서는 주소를 주로 빅 엔디언으로 쓰는데, 역사적으로 라우팅이 전화를 거는 식으로 접두 부호로 이루어졌기 때문이다. 

 

빅 엔디안은 소프트웨어의 디버그를 편하게 해주는 경향이 있다. 사람이 숫자를 읽고 쓰는 방법과 같기 때문에 디버깅 과정에서 메모리의 값을 보기 편하기 때문이다. 

 

가산기(Adder)가 덧셈을 하는 과정을 생각하면 가장 작은 자릿수부터 큰 자릿수로 진행된다. 따라서 첫 번째 바이트가 LSB인 리틀 엔디안에서는 가산기 설계가 조금 더 단순해진다. 하지만 오늘날의 프로세서는 여러 개의 바이트를 동시에 읽어 들여 동시에 덧셈을 수행하는 구조를 갖기 때문에 두 엔디안 사이에 사실상 차이가 없다.

 

숫자의 대소 관계를 비교할 때는 빅 엔디안이 조금 더 빠를 수 있다. 숫자의 비교는 가장 큰 자릿수부터 비교하기 때문에, 첫 번째 바이트가 MSB인 빅 엔디안에 대소 관계 비교는 조금 더 빠를 수 있다. 
